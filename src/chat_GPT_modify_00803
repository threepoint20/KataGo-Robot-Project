# src/vision_system.py
import cv2
import time
import numpy as np 
import json 
import os   
from _shared_utils import write_log

PARAM_FILE_NAME = 'vision_parameters.json' 
EMPTY_BOARD_TEMPLATE_FILE = 'empty_board_template.npy'

class VisionSystem:
    def __init__(self):
        write_log("VisionSystem åˆå§‹åŒ–ã€‚")
        self.cap = None 
        self.camera_index = 0 

        self.TRANSFORMED_BOARD_SIZE = 600
        self.BOARD_DIM = 19
        
        self.manual_mode = "manual_grid"
        self.manual_points = []
        self.grid_map = None
        self.manual_point_colors = [(0, 255, 255), (0, 255, 0)]
        self.control_window_name = 'Vision Parameters'
        
        self._hardcoded_default_black_stone_diff = -30
        self._hardcoded_default_white_stone_diff = 30
        self.stone_detection_roi_radius = 10
        
        self.black_stone_diff = 0
        self.white_stone_diff = 0

        self._hardcoded_default_stability_frames = 5
        self.stability_frames = 0
        self.history_buffer = {}

        self.empty_board_template = None 

        self._load_parameters()
        self.black_stone_diff = self._default_black_stone_diff
        self.white_stone_diff = self._default_white_stone_diff
        self.stability_frames = self._default_stability_frames
        
        self._create_parameter_trackbars()

    # å…¶ä»–æ–¹æ³•ç•¥ï¼ˆ_load_parameters, _set_hardcoded_defaults ç­‰ï¼‰

    def _detect_stones(self, frame):
        board_state = {}
        if self.empty_board_template is None:
            write_log("éŒ¯èª¤: æœªè¼‰å…¥ç©ºæ£‹ç›¤æ¨¡æ¿ï¼Œç„¡æ³•é€²è¡Œæ£‹å­åµæ¸¬ã€‚")
            return {}

        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        gray_template = cv2.cvtColor(self.empty_board_template, cv2.COLOR_BGR2GRAY)

        for row in range(self.BOARD_DIM):
            for col in range(self.BOARD_DIM):
                x, y = tuple(self.grid_map[row, col])

                roi_x_min = max(0, x - self.stone_detection_roi_radius)
                roi_x_max = min(gray_frame.shape[1], x + self.stone_detection_roi_radius)
                roi_y_min = max(0, y - self.stone_detection_roi_radius)
                roi_y_max = min(gray_frame.shape[0], y + self.stone_detection_roi_radius)

                roi_frame = gray_frame[roi_y_min:roi_y_max, roi_x_min:roi_x_max]
                roi_template = gray_template[roi_y_min:roi_y_max, roi_x_min:roi_x_max]

                if roi_frame.size == 0 or roi_template.size == 0:
                    continue

                difference = np.mean(roi_frame) - np.mean(roi_template)
                detected_color = None

                if difference < self.black_stone_diff:
                    detected_color = "B"
                elif difference > self.white_stone_diff:
                    detected_color = "W"
                else:
                    detected_color = None

                key = (row, col)
                if key not in self.history_buffer:
                    self.history_buffer[key] = []

                self.history_buffer[key].append(detected_color)
                if len(self.history_buffer[key]) > self.stability_frames:
                    self.history_buffer[key].pop(0)

                # åˆ¤å®šæ˜¯å¦ç©©å®š
                recent_history = self.history_buffer[key]
                if len(recent_history) == self.stability_frames:
                    if all(v == detected_color and v is not None for v in recent_history):
                        col_char = "ABCDEFGHJKLMNOPQRST"[col]
                        row_num = row + 1
                        board_state[f"{col_char}{row_num}"] = detected_color
        return board_state
        def _create_grid_map(self, points):
        if len(points) != self.BOARD_DIM * 2:
            write_log("éŒ¯èª¤: å‰µå»ºç¶²æ ¼åœ°åœ–æ‰€éœ€çš„é»æ•¸ä¸ç‚º 38ã€‚")
            return None

        x_points = np.array(points[0:self.BOARD_DIM])
        y_points = np.array(points[self.BOARD_DIM:])
        
        if len(x_points) != self.BOARD_DIM or len(y_points) != self.BOARD_DIM:
            write_log("éŒ¯èª¤: å‰µå»ºç¶²æ ¼åœ°åœ–æ™‚ï¼ŒXæˆ–Yè»¸é»æ•¸ä¸è¶³19ã€‚")
            return None
        
        grid = np.zeros((self.BOARD_DIM, self.BOARD_DIM, 2), dtype=np.int32)
        x_coords = np.interp(np.arange(self.BOARD_DIM), np.arange(self.BOARD_DIM), x_points[:, 0])
        y_coords = np.interp(np.arange(self.BOARD_DIM), np.arange(self.BOARD_DIM), y_points[:, 1])

        for row in range(self.BOARD_DIM):
            for col in range(self.BOARD_DIM):
                grid[row, col] = (int(x_coords[col]), int(y_coords[row]))
        
        write_log("å·²æˆåŠŸå‰µå»º 19x19 ç¶²æ ¼åœ°åœ–ã€‚")
        return grid

    def start_camera(self):
        self.cap = cv2.VideoCapture(self.camera_index)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
        
        if not self.cap.isOpened():
            write_log(f"éŒ¯èª¤ï¼šè¦–è¦ºç³»çµ±ç„¡æ³•æ‰“é–‹æ”å½±æ©Ÿç´¢å¼• {self.camera_index}ã€‚")
            return False

        write_log(f"è¦–è¦ºç³»çµ±æˆåŠŸé€£æ¥åˆ°æ”å½±æ©Ÿç´¢å¼• {self.camera_index}ã€‚")
        cv2.namedWindow('Vision System - Live Feed')
        cv2.setMouseCallback('Vision System - Live Feed', self._mouse_callback)
        return True

    def get_board_state(self):
        ret, frame = self.cap.read()
        if not ret:
            write_log("è¦–è¦ºç³»çµ±ï¼šç„¡æ³•å¾æ”å½±æ©Ÿè®€å–å½±åƒã€‚")
            return None
        
        processed_display_frame = frame.copy()
        board_state = {}

        if self.grid_map is not None:
            self._draw_grid_map(processed_display_frame)

            if self.empty_board_template is not None:
                write_log("ç¶²æ ¼åœ°åœ–å’Œæ¨¡æ¿å·²è¼‰å…¥ï¼Œæ­£åœ¨é€²è¡Œæ£‹å­åµæ¸¬...")
                board_state = self._detect_stones(frame)
                self._draw_stone_detections(processed_display_frame, board_state)
            else:
                write_log("è«‹å…ˆåœ¨ç©ºæ£‹ç›¤ä¸ŠæŒ‰ä¸‹ '--- Save Empty Board ---' æŒ‰éˆ•ä¾†å‰µå»ºæ¨¡æ¿ã€‚")
        else:
            if len(self.manual_points) == self.BOARD_DIM * 2:
                write_log("æ‰€æœ‰æ ¡æº–é»å·²é»é¸ã€‚è«‹æŒ‰ '--- Save Grid Map ---' æŒ‰éˆ•ä¿å­˜ç¶²æ ¼åœ°åœ–ã€‚")
                self._draw_manual_points(processed_display_frame)
            else:
                write_log(f"è«‹ä¾åºé»æ“Š {len(self.manual_points)}/{self.BOARD_DIM*2} å€‹ç¶²æ ¼é»ä»¥é€²è¡Œæ ¡æº–ã€‚")
                self._draw_manual_points(processed_display_frame)

        cv2.imshow('Vision System - Live Feed', processed_display_frame)
        return board_state

    def _draw_stone_detections(self, frame_to_draw, board_state):
        for gtp_coord, stone_color in board_state.items():
            row_char = gtp_coord[0]
            row_num_str = gtp_coord[1:]

            if row_char not in "ABCDEFGHJKLMNOPQRST":
                continue
            if not row_num_str.isdigit():
                continue

            row = int(row_num_str) - 1
            col = "ABCDEFGHJKLMNOPQRST".index(row_char)
            p = tuple(self.grid_map[row, col])

            color_to_draw = (0, 0, 0) if stone_color == "B" else (255, 255, 255)
            cv2.circle(frame_to_draw, p, self.stone_detection_roi_radius, (0, 255, 255), 2)
            cv2.circle(frame_to_draw, p, self.stone_detection_roi_radius - 2, color_to_draw, -1)
            cv2.putText(frame_to_draw, stone_color, (p[0] - 5, p[1] + 5),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2, cv2.LINE_AA)

    def detect_human_move(self, prev_board_state, current_board_state):
        pass

    def stop_camera(self):
        if self.cap and self.cap.isOpened():
            self.cap.release()
        cv2.destroyAllWindows()
        write_log("è¦–è¦ºç³»çµ±æ”å½±æ©Ÿå·²åœæ­¢ã€‚")

    def _draw_manual_points(self, frame_to_draw):
        for i, p in enumerate(self.manual_points):
            color = self.manual_point_colors[i % 2]
            cv2.circle(frame_to_draw, p, 10, color, -1)
            if i < self.BOARD_DIM:
                text = f"X:{i+1}"
            else:
                text = f"Y:{i-self.BOARD_DIM+1}"
            cv2.putText(frame_to_draw, text, (p[0] + 15, p[1] + 15),
                        cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2, cv2.LINE_AA)

    def _draw_grid_map(self, frame_to_draw):
        if self.grid_map is not None:
            for row in range(self.BOARD_DIM):
                for col in range(self.BOARD_DIM):
                    p = tuple(self.grid_map[row, col])
                    cv2.circle(frame_to_draw, p, 5, (0, 255, 0), -1)
                    if row < self.BOARD_DIM - 1:
                        p2 = tuple(self.grid_map[row + 1, col])
                        cv2.line(frame_to_draw, p, p2, (0, 255, 0), 1)
                    if col < self.BOARD_DIM - 1:
                        p2 = tuple(self.grid_map[row, col + 1])
                        cv2.line(frame_to_draw, p, p2, (0, 255, 0), 1)
                        if __name__ == "__main__":
    vision_system = None
    try:
        vision_system = VisionSystem()
        if not vision_system.start_camera():
            write_log("è¦–è¦ºç³»çµ±å•Ÿå‹•å¤±æ•—ï¼Œç„¡æ³•é€²è¡Œå–®ç¨æ¸¬è©¦ã€‚")
            exit(1)
        write_log("\nâœ… VisionSystem å–®ç¨æ¸¬è©¦æ¨¡å¼å·²å•Ÿå‹•ã€‚")

        if vision_system.grid_map is None:
            write_log("---")
            write_log("æœªæ‰¾åˆ°å·²ä¿å­˜çš„ç¶²æ ¼åœ°åœ–ã€‚è«‹é»æ“Š 'Live Feed' è¦–çª—é–‹å§‹æ‰‹å‹•æ ¡æº–ã€‚")
            write_log("é»æ“Šé †åºï¼šå¾å·¦ä¸‹è§’é–‹å§‹ï¼Œæ²¿è‘—æœ€åº•å±¤æ°´å¹³ç·šé»æ“Š19å€‹é»ï¼Œç„¶å¾Œå†æ²¿è‘—æœ€å·¦å´å‚ç›´ç·šé»æ“Š19å€‹é»ã€‚")
            write_log("---")

        while True:
            board_state = vision_system.get_board_state()
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                write_log("ç”¨æˆ¶æ‰‹å‹•é€€å‡º VisionSystem å–®ç¨æ¸¬è©¦ã€‚")
                break

    except Exception as e:
        write_log(f"\nğŸš¨ VisionSystem å–®ç¨æ¸¬è©¦ç™¼ç”ŸéŒ¯èª¤ï¼š{e}")
    finally:
        if vision_system:
            vision_system.stop_camera()
        write_log("VisionSystem å–®ç¨æ¸¬è©¦ç¨‹å¼çµæŸã€‚")