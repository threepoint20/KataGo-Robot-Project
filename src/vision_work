import cv2
import time
import numpy as np 
import json 
import os   
from _shared_utils import write_log

# --- å®šç¾©åƒæ•¸å„²å­˜æª”æ¡ˆçš„è·¯å¾‘ ---
PARAM_FILE_NAME = 'vision_parameters.json' 

class VisionSystem:
    def __init__(self):
        write_log("VisionSystem åˆå§‹åŒ–ã€‚")
        self.cap = None 
        self.camera_index = 0 

        self.TRANSFORMED_BOARD_SIZE = 600
        self.BOARD_DIM = 19
        
        # --- æ‰‹å‹•é¸é»æ¨¡å¼ç›¸é—œå±¬æ€§ ---
        self.manual_mode = "manual_grid"
        self.manual_points = []
        self.grid_map = None
        self.manual_point_colors = [(0, 255, 255), (0, 255, 0)]
        self.control_window_name = 'Vision Parameters'

        # --- ç¡¬ç·¨ç¢¼çš„åŸå§‹é è¨­å€¼ ---
        self._hardcoded_default_canny_threshold1 = 100 
        self._hardcoded_default_canny_threshold2 = 200 
        self.canny_max_threshold = 500
        self._hardcoded_default_hough_threshold = 15     
        self._hardcoded_default_hough_min_line_length = 50 
        self._hardcoded_default_hough_max_line_gap = 20    
        self.hough_max_threshold = 200
        self.hough_max_line_length = 300
        self.hough_max_line_gap = 100
        self._hardcoded_default_ransac_iterations = 500 
        self._hardcoded_default_ransac_line_tolerance = 5 
        self._hardcoded_default_ransac_min_inliers_ratio = 0.7 
        self.ransac_max_iterations = 2000 
        self.ransac_max_line_tolerance = 20 
        self._hardcoded_default_black_stone_thresh = 50
        self._hardcoded_default_white_stone_thresh = 180
        self.stone_detection_roi_radius = 10
        
        # --- è¼‰å…¥åƒæ•¸ä¸¦è¨­å®šåˆå§‹å€¼ ---
        self._load_parameters()
        self.black_stone_thresh = self._default_black_stone_thresh
        self.white_stone_thresh = self._default_white_stone_thresh
        self.canny_threshold1 = self._default_canny_threshold1
        self.canny_threshold2 = self._default_canny_threshold2
        self.hough_threshold = self._default_hough_threshold
        self.hough_min_line_length = self._default_hough_min_line_length
        self.hough_max_line_gap = self._default_hough_max_line_gap
        self.ransac_iterations = self._default_ransac_iterations
        self.ransac_line_tolerance = self._default_ransac_line_tolerance
        self.ransac_min_inliers_ratio = self._default_ransac_min_inliers_ratio
        
        # å‰µå»º UI ä»‹é¢è¦–çª—å’Œæ»‘æ¡¿
        self._create_parameter_trackbars()

    def _load_parameters(self):
        """å˜—è©¦å¾æª”æ¡ˆè¼‰å…¥åƒæ•¸ï¼Œå¦‚æœå¤±æ•—å‰‡ä½¿ç”¨ç¡¬ç·¨ç¢¼é è¨­å€¼ã€‚"""
        self._loaded_params = {} 
        try:
            if not os.path.exists(PARAM_FILE_NAME):
                raise FileNotFoundError 

            with open(PARAM_FILE_NAME, 'r') as f:
                params = json.load(f)
                self._loaded_params = params 
                
                self._default_canny_threshold1 = params.get('canny_threshold1', 100)
                self._default_canny_threshold2 = params.get('canny_threshold2', 200)
                self._default_hough_threshold = params.get('hough_threshold', 15)
                self._default_hough_min_line_length = params.get('hough_min_line_length', 50)
                self._default_hough_max_line_gap = params.get('hough_max_line_gap', 20)
                self._default_ransac_iterations = params.get('ransac_iterations', 500)
                self._default_ransac_line_tolerance = params.get('ransac_line_tolerance', 5)
                self._default_ransac_min_inliers_ratio = params.get('ransac_min_inliers_ratio', 0.7)
                self._default_black_stone_thresh = params.get('black_stone_thresh', self._hardcoded_default_black_stone_thresh)
                self._default_white_stone_thresh = params.get('white_stone_thresh', self._hardcoded_default_white_stone_thresh)
                
                write_log(f"åƒæ•¸å¾ '{PARAM_FILE_NAME}' è¼‰å…¥æˆåŠŸã€‚")
        except FileNotFoundError:
            write_log(f"åƒæ•¸æª”æ¡ˆ '{PARAM_FILE_NAME}' æœªæ‰¾åˆ°ï¼Œä½¿ç”¨ç¡¬ç·¨ç¢¼é è¨­å€¼ã€‚")
            self._set_hardcoded_defaults()
        except json.JSONDecodeError:
            write_log(f"åƒæ•¸æª”æ¡ˆ '{PARAM_FILE_NAME}' æ ¼å¼éŒ¯èª¤ï¼Œä½¿ç”¨ç¡¬ç·¨ç¢¼é è¨­å€¼ã€‚")
            self._set_hardcoded_defaults()
        except Exception as e:
            write_log(f"è¼‰å…¥åƒæ•¸æ™‚ç™¼ç”Ÿæ„å¤–éŒ¯èª¤: {e}ï¼Œä½¿ç”¨ç¡¬ç·¨ç¢¼é è¨­å€¼ã€‚")
            self._set_hardcoded_defaults()
        
        if '_saved_grid_map' in self._loaded_params and self._loaded_params['_saved_grid_map']:
            self.grid_map = np.array(self._loaded_params['_saved_grid_map'])
            write_log("å·²è¼‰å…¥ä¿å­˜çš„æ‰‹å‹•ç¶²æ ¼åœ°åœ–ã€‚")
            self.manual_mode = "manual_grid"
        else:
            self.manual_points = []
            self.grid_map = None

    def _set_hardcoded_defaults(self):
        self._default_canny_threshold1 = self._hardcoded_default_canny_threshold1
        self._default_canny_threshold2 = self._hardcoded_default_canny_threshold2
        self._default_hough_threshold = self._hardcoded_default_hough_threshold
        self._default_hough_min_line_length = self._hardcoded_default_hough_min_line_length
        self._default_hough_max_line_gap = self._hardcoded_default_hough_max_line_gap
        self._default_ransac_iterations = self._hardcoded_default_ransac_iterations
        self._default_ransac_line_tolerance = self._hardcoded_default_ransac_line_tolerance
        self._default_ransac_min_inliers_ratio = self._hardcoded_default_ransac_min_inliers_ratio
        self._default_black_stone_thresh = self._hardcoded_default_black_stone_thresh
        self._default_white_stone_thresh = self._hardcoded_default_white_stone_thresh

    def _save_parameters(self):
        """å°‡ç•¶å‰åƒæ•¸ä¿å­˜åˆ°æª”æ¡ˆä¸­ï¼Œä¸¦æ›´æ–°ç‚ºæ–°çš„é è¨­å€¼ã€‚"""
        params_to_save = {
            'canny_threshold1': self.canny_threshold1,
            'canny_threshold2': self.canny_threshold2,
            'hough_threshold': self.hough_threshold,
            'hough_min_line_length': self.hough_min_line_length,
            'hough_max_line_gap': self.hough_max_line_gap,
            'ransac_iterations': self.ransac_iterations,
            'ransac_line_tolerance': self.ransac_line_tolerance,
            'ransac_min_inliers_ratio': self.ransac_min_inliers_ratio,
            'black_stone_thresh': self.black_stone_thresh,
            'white_stone_thresh': self.white_stone_thresh,
            '_saved_grid_map': self.grid_map.tolist() if self.manual_mode == "manual_grid" and self.grid_map is not None else None,
        }
        try:
            with open(PARAM_FILE_NAME, 'w') as f:
                json.dump(params_to_save, f, indent=4)
            write_log(f"åƒæ•¸æˆåŠŸä¿å­˜åˆ° '{PARAM_FILE_NAME}'ã€‚")
            
            self._default_canny_threshold1 = self.canny_threshold1
            self._default_canny_threshold2 = self.canny_threshold2
            self._default_hough_threshold = self.hough_threshold
            self._default_hough_min_line_length = self.hough_min_line_length
            self._default_hough_max_line_gap = self.hough_max_line_gap
            self._default_ransac_iterations = self.ransac_iterations
            self._default_ransac_line_tolerance = self.ransac_line_tolerance
            self._default_ransac_min_inliers_ratio = self.ransac_min_inliers_ratio
            self._default_black_stone_thresh = self.black_stone_thresh
            self._default_white_stone_thresh = self.white_stone_thresh
        except Exception as e:
            write_log(f"ä¿å­˜åƒæ•¸åˆ° '{PARAM_FILE_NAME}' æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

    def _create_parameter_trackbars(self):
        """å‰µå»ºç”¨æ–¼èª¿æ•´å½±åƒè™•ç†åƒæ•¸çš„æ»‘æ¡¿ UIã€‚"""
        self.control_window_name = 'Vision Parameters'
        cv2.namedWindow(self.control_window_name)
        control_window_img = np.zeros((100, 500, 3), dtype=np.uint8)
        cv2.imshow(self.control_window_name, control_window_img)

        cv2.createTrackbar('Black Thresh', self.control_window_name, self.black_stone_thresh, 255, self._on_black_stone_thresh_change)
        cv2.createTrackbar('White Thresh', self.control_window_name, self.white_stone_thresh, 255, self._on_white_stone_thresh_change)
        cv2.createTrackbar('Clear Points', self.control_window_name, 0, 1, self._on_clear_manual_points)
        cv2.createTrackbar('--- Reset All ---', self.control_window_name, 0, 1, self._on_reset_button_press)
        cv2.createTrackbar('--- Save Grid Map ---', self.control_window_name, 0, 1, self._on_save_button_press)

        write_log("è¦–è¦ºåƒæ•¸èª¿æ•´ UI å·²å‰µå»ºã€‚")

    def _on_black_stone_thresh_change(self, val):
        self.black_stone_thresh = val
        write_log(f"é»‘å­é–¾å€¼æ›´æ–°ç‚º: {self.black_stone_thresh}")

    def _on_white_stone_thresh_change(self, val):
        self.white_stone_thresh = val
        if self.white_stone_thresh <= self.black_stone_thresh:
            self.white_stone_thresh = self.black_stone_thresh + 1
            if self.white_stone_thresh > 255:
                self.white_stone_thresh = 255
            cv2.setTrackbarPos('White Thresh', self.control_window_name, self.white_stone_thresh)
        write_log(f"ç™½å­é–¾å€¼æ›´æ–°ç‚º: {self.white_stone_thresh}")

    def _on_clear_manual_points(self, val):
        if val == 1:
            write_log("æ¸…é™¤æ‰€æœ‰æ‰‹å‹•é¸æ“‡çš„é»ã€‚")
            self.manual_points = []
            self.grid_map = None
            cv2.setTrackbarPos('Clear Points', self.control_window_name, 0)

    def _on_reset_button_press(self, val):
        if val == 1: 
            write_log("é‡ç½®æ‰€æœ‰é»å’Œç¶²æ ¼åœ°åœ–ã€‚")
            self.manual_points = []
            self.grid_map = None
            cv2.setTrackbarPos('Clear Points', self.control_window_name, 0)
            cv2.setTrackbarPos('--- Reset All ---', self.control_window_name, 0)

    def _on_save_button_press(self, val):
        if val == 1: 
            self._save_parameters()
            cv2.setTrackbarPos('--- Save Grid Map ---', self.control_window_name, 0) 

    def _mouse_callback(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            if self.manual_mode == "manual_grid":
                if len(self.manual_points) < self.BOARD_DIM * 2: 
                    self.manual_points.append((x, y))
                    write_log(f"æ‰‹å‹•ç¶²æ ¼æ¨¡å¼ï¼šé»æ“Šé» {len(self.manual_points)}/{self.BOARD_DIM*2}: ({x}, {y})")
                    if len(self.manual_points) == self.BOARD_DIM * 2:
                        write_log("å·²é»é¸æ‰€æœ‰ç¶²æ ¼æ ¡æº–é»ã€‚æ­£åœ¨å»ºç«‹ç¶²æ ¼åœ°åœ–...")
                        self.grid_map = self._create_grid_map(self.manual_points)
                        if self.grid_map is not None:
                             write_log("ç¶²æ ¼åœ°åœ–å‰µå»ºæˆåŠŸã€‚")
                        else:
                            write_log("éŒ¯èª¤: ç¶²æ ¼åœ°åœ–å‰µå»ºå¤±æ•—ï¼Œè«‹é‡è©¦ã€‚")
                            self.manual_points = [] 
                            cv2.setTrackbarPos('Clear Points', self.control_window_name, 0)

    def _create_grid_map(self, points):
        """å¾æ‰‹å‹•é»é¸çš„ 38 å€‹é»å»ºç«‹ä¸€å€‹ 19x19 çš„ç¶²æ ¼åœ°åœ–ã€‚"""
        if len(points) != self.BOARD_DIM * 2:
            write_log("éŒ¯èª¤: å‰µå»ºç¶²æ ¼åœ°åœ–æ‰€éœ€çš„é»æ•¸ä¸ç‚º 38ã€‚")
            return None
        
        x_points = np.array(points[0:self.BOARD_DIM])
        y_points = np.array(points[self.BOARD_DIM:])
        
        if len(x_points) != self.BOARD_DIM or len(y_points) != self.BOARD_DIM:
            write_log("éŒ¯èª¤: å‰µå»ºç¶²æ ¼åœ°åœ–æ™‚ï¼ŒXæˆ–Yè»¸é»æ•¸ä¸è¶³19ã€‚")
            return None
        grid = np.zeros((self.BOARD_DIM, self.BOARD_DIM, 2), dtype=np.int32)
        x_coords_of_x_points = x_points[:,0]
        y_coords_of_y_points = y_points[:,1]
        x_coords = np.interp(np.arange(self.BOARD_DIM), np.arange(self.BOARD_DIM), x_coords_of_x_points)
        y_coords = np.interp(np.arange(self.BOARD_DIM), np.arange(self.BOARD_DIM), y_coords_of_y_points)
        for row in range(self.BOARD_DIM):
            for col in range(self.BOARD_DIM):
                grid[row, col] = (int(x_coords[col]), int(y_coords[row]))
        write_log("å·²æˆåŠŸå‰µå»º 19x19 ç¶²æ ¼åœ°åœ–ã€‚")
        return grid

    def start_camera(self):
        self.cap = cv2.VideoCapture(self.camera_index)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
        
        if not self.cap.isOpened():
            write_log(f"éŒ¯èª¤ï¼šè¦–è¦ºç³»çµ±ç„¡æ³•æ‰“é–‹æ”å½±æ©Ÿç´¢å¼• {self.camera_index}ã€‚")
            return False
        write_log(f"è¦–è¦ºç³»çµ±æˆåŠŸé€£æ¥åˆ°æ”å½±æ©Ÿç´¢å¼• {self.camera_index}ã€‚")
        
        cv2.namedWindow('Vision System - Live Feed')
        cv2.setMouseCallback('Vision System - Live Feed', self._mouse_callback)
        return True

    def get_board_state(self):
        ret, frame = self.cap.read()
        if not ret:
            write_log("è¦–è¦ºç³»çµ±ï¼šç„¡æ³•å¾æ”å½±æ©Ÿè®€å–å½±åƒã€‚")
            return None
        
        processed_display_frame = frame.copy() 
        board_state = {}

        if self.grid_map is not None:
            self._draw_grid_map(processed_display_frame)
            write_log("ç¶²æ ¼åœ°åœ–å·²è¼‰å…¥ï¼Œæ­£åœ¨é€²è¡Œæ£‹å­åµæ¸¬...")
            board_state = self._detect_stones(frame)
            self._draw_stone_detections(processed_display_frame, board_state)
        elif len(self.manual_points) == self.BOARD_DIM * 2:
            write_log("æ‰€æœ‰æ ¡æº–é»å·²é»é¸ã€‚è«‹æŒ‰ '--- Save Grid Map ---' æŒ‰éˆ•ä¿å­˜ç¶²æ ¼åœ°åœ–ã€‚")
            self._draw_manual_points(processed_display_frame)
        else:
            write_log(f"è«‹ä¾åºé»æ“Š {len(self.manual_points)}/{self.BOARD_DIM*2} å€‹ç¶²æ ¼é»ä»¥é€²è¡Œæ ¡æº–ã€‚")
            self._draw_manual_points(processed_display_frame)

        cv2.imshow('Vision System - Live Feed', processed_display_frame)
        control_window_img = np.zeros((100, 500, 3), dtype=np.uint8)
        cv2.imshow(self.control_window_name, control_window_img)
        
        return board_state

    def _detect_stones(self, frame):
        """åœ¨å·²æ ¡æº–çš„ç¶²æ ¼ä¸Šåµæ¸¬é»‘å­å’Œç™½å­ã€‚"""
        board_state = {}
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        for row in range(self.BOARD_DIM):
            for col in range(self.BOARD_DIM):
                x, y = tuple(self.grid_map[row, col])
                
                roi_x_min = max(0, x - self.stone_detection_roi_radius)
                roi_x_max = min(gray_frame.shape[1], x + self.stone_detection_roi_radius)
                roi_y_min = max(0, y - self.stone_detection_roi_radius)
                roi_y_max = min(gray_frame.shape[0], y + self.stone_detection_roi_radius)
                
                roi = gray_frame[roi_y_min:roi_y_max, roi_x_min:roi_x_max]
                if roi.size == 0:
                    continue

                average_brightness = np.mean(roi)
                if average_brightness < self.black_stone_thresh:
                    col_char = "ABCDEFGHJKLMNOPQRST"[col]
                    row_num = row + 1
                    board_state[f"{col_char}{row_num}"] = "B"
                elif average_brightness > self.white_stone_thresh:
                    col_char = "ABCDEFGHJKLMNOPQRST"[col]
                    row_num = row + 1
                    board_state[f"{col_char}{row_num}"] = "W"
        
        write_log(f"æ£‹å­åµæ¸¬çµæœï¼šåµæ¸¬åˆ° {len(board_state)} å€‹æ£‹å­ã€‚")
        return board_state

    def _draw_stone_detections(self, frame_to_draw, board_state):
        """åœ¨å½±åƒä¸Šç¹ªè£½æ£‹å­åµæ¸¬çš„çµæœï¼Œä¸¦ç”¨é¡è‰²æ¨™è¨˜"""
        for gtp_coord, stone_color in board_state.items():
            row = int(gtp_coord[1:]) - 1
            col = "ABCDEFGHJKLMNOPQRST".index(gtp_coord[0])
            p = tuple(self.grid_map[row, col])
            
            color_to_draw = (0, 0, 0) if stone_color == "B" else (255, 255, 255)
            cv2.circle(frame_to_draw, p, self.stone_detection_roi_radius, (0, 255, 255), 2)
            cv2.circle(frame_to_draw, p, self.stone_detection_roi_radius - 2, color_to_draw, -1)
            cv2.putText(frame_to_draw, stone_color, (p[0] - 5, p[1] + 5), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2, cv2.LINE_AA)

    def detect_human_move(self, prev_board_state, current_board_state):
        pass

    def stop_camera(self):
        if self.cap and self.cap.isOpened():
            self.cap.release()
        cv2.destroyAllWindows() 
        write_log("è¦–è¦ºç³»çµ±æ”å½±æ©Ÿå·²åœæ­¢ã€‚")

    def _draw_manual_points(self, frame_to_draw):
        for i, p in enumerate(self.manual_points):
            color = self.manual_point_colors[i % 2]
            cv2.circle(frame_to_draw, p, 10, color, -1)
            if i < self.BOARD_DIM:
                text = f"X:{i+1}"
            else:
                text = f"Y:{i-self.BOARD_DIM+1}"
            cv2.putText(frame_to_draw, text, (p[0] + 15, p[1] + 15), 
                        cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2, cv2.LINE_AA)

    def _draw_grid_map(self, frame_to_draw):
        if self.grid_map is not None:
            for row in range(self.BOARD_DIM):
                for col in range(self.BOARD_DIM):
                    p = tuple(self.grid_map[row, col])
                    cv2.circle(frame_to_draw, p, 5, (0, 255, 0), -1) 
                    if row < self.BOARD_DIM - 1:
                        p2 = tuple(self.grid_map[row + 1, col])
                        cv2.line(frame_to_draw, p, p2, (0, 255, 0), 1)
                    if col < self.BOARD_DIM - 1:
                        p2 = tuple(self.grid_map[row, col + 1])
                        cv2.line(frame_to_draw, p, p2, (0, 255, 0), 1)

    def _sort_manual_corners(self, corners):
        corners = np.array(corners, dtype="float32")
        s = corners.sum(axis=1)
        top_left = corners[np.argmin(s)]
        bottom_right = corners[np.argmax(s)]
        diff = np.diff(corners, axis=1)
        top_right = corners[np.argmin(diff)] 
        bottom_left = corners[np.argmax(diff)] 
        return np.array([top_left, top_right, bottom_right, bottom_left], dtype="float32")

if __name__ == "__main__":
    vision_system = None
    try:
        vision_system = VisionSystem()
        if not vision_system.start_camera():
            write_log("è¦–è¦ºç³»çµ±å•Ÿå‹•å¤±æ•—ï¼Œç„¡æ³•é€²è¡Œå–®ç¨æ¸¬è©¦ã€‚")
            exit(1)
        write_log("\nâœ… VisionSystem å–®ç¨æ¸¬è©¦æ¨¡å¼å·²å•Ÿå‹•ã€‚")
        write_log("è«‹å°‡åœæ£‹ç›¤ç½®æ–¼æ”å½±æ©Ÿä¸‹æ–¹ã€‚æŒ‰ 'q' éµé€€å‡ºæ‰€æœ‰è¦–çª—ã€‚")

        while True:
            board_state = vision_system.get_board_state()
            write_log(f"ç•¶å‰é»‘å­é–¾å€¼: {vision_system.black_stone_thresh}, ç™½å­é–¾å€¼: {vision_system.white_stone_thresh}")
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                write_log("ç”¨æˆ¶æ‰‹å‹•é€€å‡º VisionSystem å–®ç¨æ¸¬è©¦ã€‚")
                break
            
    except Exception as e:
        write_log(f"\nğŸš¨ VisionSystem å–®ç¨æ¸¬è©¦ç™¼ç”ŸéŒ¯èª¤ï¼š{e}")
    finally:
        if vision_system:
            vision_system.stop_camera()
        write_log("VisionSystem å–®ç¨æ¸¬è©¦ç¨‹å¼çµæŸã€‚")