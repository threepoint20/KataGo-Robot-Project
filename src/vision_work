import cv2
import time
import numpy as np 
import json 
import os   
from _shared_utils import write_log

# --- 定義參數儲存檔案的路徑 ---
PARAM_FILE_NAME = 'vision_parameters.json' 

class VisionSystem:
    def __init__(self):
        write_log("VisionSystem 初始化。")
        self.cap = None 
        self.camera_index = 0 

        self.TRANSFORMED_BOARD_SIZE = 600
        self.BOARD_DIM = 19
        
        # --- 手動選點模式相關屬性 ---
        self.manual_mode = "manual_grid"
        self.manual_points = []
        self.grid_map = None
        self.manual_point_colors = [(0, 255, 255), (0, 255, 0)]
        self.control_window_name = 'Vision Parameters'

        # --- 硬編碼的原始預設值 ---
        self._hardcoded_default_canny_threshold1 = 100 
        self._hardcoded_default_canny_threshold2 = 200 
        self.canny_max_threshold = 500
        self._hardcoded_default_hough_threshold = 15     
        self._hardcoded_default_hough_min_line_length = 50 
        self._hardcoded_default_hough_max_line_gap = 20    
        self.hough_max_threshold = 200
        self.hough_max_line_length = 300
        self.hough_max_line_gap = 100
        self._hardcoded_default_ransac_iterations = 500 
        self._hardcoded_default_ransac_line_tolerance = 5 
        self._hardcoded_default_ransac_min_inliers_ratio = 0.7 
        self.ransac_max_iterations = 2000 
        self.ransac_max_line_tolerance = 20 
        self._hardcoded_default_black_stone_thresh = 50
        self._hardcoded_default_white_stone_thresh = 180
        self.stone_detection_roi_radius = 10
        
        # --- 載入參數並設定初始值 ---
        self._load_parameters()
        self.black_stone_thresh = self._default_black_stone_thresh
        self.white_stone_thresh = self._default_white_stone_thresh
        self.canny_threshold1 = self._default_canny_threshold1
        self.canny_threshold2 = self._default_canny_threshold2
        self.hough_threshold = self._default_hough_threshold
        self.hough_min_line_length = self._default_hough_min_line_length
        self.hough_max_line_gap = self._default_hough_max_line_gap
        self.ransac_iterations = self._default_ransac_iterations
        self.ransac_line_tolerance = self._default_ransac_line_tolerance
        self.ransac_min_inliers_ratio = self._default_ransac_min_inliers_ratio
        
        # 創建 UI 介面視窗和滑桿
        self._create_parameter_trackbars()

    def _load_parameters(self):
        """嘗試從檔案載入參數，如果失敗則使用硬編碼預設值。"""
        self._loaded_params = {} 
        try:
            if not os.path.exists(PARAM_FILE_NAME):
                raise FileNotFoundError 

            with open(PARAM_FILE_NAME, 'r') as f:
                params = json.load(f)
                self._loaded_params = params 
                
                self._default_canny_threshold1 = params.get('canny_threshold1', 100)
                self._default_canny_threshold2 = params.get('canny_threshold2', 200)
                self._default_hough_threshold = params.get('hough_threshold', 15)
                self._default_hough_min_line_length = params.get('hough_min_line_length', 50)
                self._default_hough_max_line_gap = params.get('hough_max_line_gap', 20)
                self._default_ransac_iterations = params.get('ransac_iterations', 500)
                self._default_ransac_line_tolerance = params.get('ransac_line_tolerance', 5)
                self._default_ransac_min_inliers_ratio = params.get('ransac_min_inliers_ratio', 0.7)
                self._default_black_stone_thresh = params.get('black_stone_thresh', self._hardcoded_default_black_stone_thresh)
                self._default_white_stone_thresh = params.get('white_stone_thresh', self._hardcoded_default_white_stone_thresh)
                
                write_log(f"參數從 '{PARAM_FILE_NAME}' 載入成功。")
        except FileNotFoundError:
            write_log(f"參數檔案 '{PARAM_FILE_NAME}' 未找到，使用硬編碼預設值。")
            self._set_hardcoded_defaults()
        except json.JSONDecodeError:
            write_log(f"參數檔案 '{PARAM_FILE_NAME}' 格式錯誤，使用硬編碼預設值。")
            self._set_hardcoded_defaults()
        except Exception as e:
            write_log(f"載入參數時發生意外錯誤: {e}，使用硬編碼預設值。")
            self._set_hardcoded_defaults()
        
        if '_saved_grid_map' in self._loaded_params and self._loaded_params['_saved_grid_map']:
            self.grid_map = np.array(self._loaded_params['_saved_grid_map'])
            write_log("已載入保存的手動網格地圖。")
            self.manual_mode = "manual_grid"
        else:
            self.manual_points = []
            self.grid_map = None

    def _set_hardcoded_defaults(self):
        self._default_canny_threshold1 = self._hardcoded_default_canny_threshold1
        self._default_canny_threshold2 = self._hardcoded_default_canny_threshold2
        self._default_hough_threshold = self._hardcoded_default_hough_threshold
        self._default_hough_min_line_length = self._hardcoded_default_hough_min_line_length
        self._default_hough_max_line_gap = self._hardcoded_default_hough_max_line_gap
        self._default_ransac_iterations = self._hardcoded_default_ransac_iterations
        self._default_ransac_line_tolerance = self._hardcoded_default_ransac_line_tolerance
        self._default_ransac_min_inliers_ratio = self._hardcoded_default_ransac_min_inliers_ratio
        self._default_black_stone_thresh = self._hardcoded_default_black_stone_thresh
        self._default_white_stone_thresh = self._hardcoded_default_white_stone_thresh

    def _save_parameters(self):
        """將當前參數保存到檔案中，並更新為新的預設值。"""
        params_to_save = {
            'canny_threshold1': self.canny_threshold1,
            'canny_threshold2': self.canny_threshold2,
            'hough_threshold': self.hough_threshold,
            'hough_min_line_length': self.hough_min_line_length,
            'hough_max_line_gap': self.hough_max_line_gap,
            'ransac_iterations': self.ransac_iterations,
            'ransac_line_tolerance': self.ransac_line_tolerance,
            'ransac_min_inliers_ratio': self.ransac_min_inliers_ratio,
            'black_stone_thresh': self.black_stone_thresh,
            'white_stone_thresh': self.white_stone_thresh,
            '_saved_grid_map': self.grid_map.tolist() if self.manual_mode == "manual_grid" and self.grid_map is not None else None,
        }
        try:
            with open(PARAM_FILE_NAME, 'w') as f:
                json.dump(params_to_save, f, indent=4)
            write_log(f"參數成功保存到 '{PARAM_FILE_NAME}'。")
            
            self._default_canny_threshold1 = self.canny_threshold1
            self._default_canny_threshold2 = self.canny_threshold2
            self._default_hough_threshold = self.hough_threshold
            self._default_hough_min_line_length = self.hough_min_line_length
            self._default_hough_max_line_gap = self.hough_max_line_gap
            self._default_ransac_iterations = self.ransac_iterations
            self._default_ransac_line_tolerance = self.ransac_line_tolerance
            self._default_ransac_min_inliers_ratio = self.ransac_min_inliers_ratio
            self._default_black_stone_thresh = self.black_stone_thresh
            self._default_white_stone_thresh = self.white_stone_thresh
        except Exception as e:
            write_log(f"保存參數到 '{PARAM_FILE_NAME}' 時發生錯誤: {e}")

    def _create_parameter_trackbars(self):
        """創建用於調整影像處理參數的滑桿 UI。"""
        self.control_window_name = 'Vision Parameters'
        cv2.namedWindow(self.control_window_name)
        control_window_img = np.zeros((100, 500, 3), dtype=np.uint8)
        cv2.imshow(self.control_window_name, control_window_img)

        cv2.createTrackbar('Black Thresh', self.control_window_name, self.black_stone_thresh, 255, self._on_black_stone_thresh_change)
        cv2.createTrackbar('White Thresh', self.control_window_name, self.white_stone_thresh, 255, self._on_white_stone_thresh_change)
        cv2.createTrackbar('Clear Points', self.control_window_name, 0, 1, self._on_clear_manual_points)
        cv2.createTrackbar('--- Reset All ---', self.control_window_name, 0, 1, self._on_reset_button_press)
        cv2.createTrackbar('--- Save Grid Map ---', self.control_window_name, 0, 1, self._on_save_button_press)

        write_log("視覺參數調整 UI 已創建。")

    def _on_black_stone_thresh_change(self, val):
        self.black_stone_thresh = val
        write_log(f"黑子閾值更新為: {self.black_stone_thresh}")

    def _on_white_stone_thresh_change(self, val):
        self.white_stone_thresh = val
        if self.white_stone_thresh <= self.black_stone_thresh:
            self.white_stone_thresh = self.black_stone_thresh + 1
            if self.white_stone_thresh > 255:
                self.white_stone_thresh = 255
            cv2.setTrackbarPos('White Thresh', self.control_window_name, self.white_stone_thresh)
        write_log(f"白子閾值更新為: {self.white_stone_thresh}")

    def _on_clear_manual_points(self, val):
        if val == 1:
            write_log("清除所有手動選擇的點。")
            self.manual_points = []
            self.grid_map = None
            cv2.setTrackbarPos('Clear Points', self.control_window_name, 0)

    def _on_reset_button_press(self, val):
        if val == 1: 
            write_log("重置所有點和網格地圖。")
            self.manual_points = []
            self.grid_map = None
            cv2.setTrackbarPos('Clear Points', self.control_window_name, 0)
            cv2.setTrackbarPos('--- Reset All ---', self.control_window_name, 0)

    def _on_save_button_press(self, val):
        if val == 1: 
            self._save_parameters()
            cv2.setTrackbarPos('--- Save Grid Map ---', self.control_window_name, 0) 

    def _mouse_callback(self, event, x, y, flags, param):
        if event == cv2.EVENT_LBUTTONDOWN:
            if self.manual_mode == "manual_grid":
                if len(self.manual_points) < self.BOARD_DIM * 2: 
                    self.manual_points.append((x, y))
                    write_log(f"手動網格模式：點擊點 {len(self.manual_points)}/{self.BOARD_DIM*2}: ({x}, {y})")
                    if len(self.manual_points) == self.BOARD_DIM * 2:
                        write_log("已點選所有網格校準點。正在建立網格地圖...")
                        self.grid_map = self._create_grid_map(self.manual_points)
                        if self.grid_map is not None:
                             write_log("網格地圖創建成功。")
                        else:
                            write_log("錯誤: 網格地圖創建失敗，請重試。")
                            self.manual_points = [] 
                            cv2.setTrackbarPos('Clear Points', self.control_window_name, 0)

    def _create_grid_map(self, points):
        """從手動點選的 38 個點建立一個 19x19 的網格地圖。"""
        if len(points) != self.BOARD_DIM * 2:
            write_log("錯誤: 創建網格地圖所需的點數不為 38。")
            return None
        
        x_points = np.array(points[0:self.BOARD_DIM])
        y_points = np.array(points[self.BOARD_DIM:])
        
        if len(x_points) != self.BOARD_DIM or len(y_points) != self.BOARD_DIM:
            write_log("錯誤: 創建網格地圖時，X或Y軸點數不足19。")
            return None
        grid = np.zeros((self.BOARD_DIM, self.BOARD_DIM, 2), dtype=np.int32)
        x_coords_of_x_points = x_points[:,0]
        y_coords_of_y_points = y_points[:,1]
        x_coords = np.interp(np.arange(self.BOARD_DIM), np.arange(self.BOARD_DIM), x_coords_of_x_points)
        y_coords = np.interp(np.arange(self.BOARD_DIM), np.arange(self.BOARD_DIM), y_coords_of_y_points)
        for row in range(self.BOARD_DIM):
            for col in range(self.BOARD_DIM):
                grid[row, col] = (int(x_coords[col]), int(y_coords[row]))
        write_log("已成功創建 19x19 網格地圖。")
        return grid

    def start_camera(self):
        self.cap = cv2.VideoCapture(self.camera_index)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1280)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 720)
        
        if not self.cap.isOpened():
            write_log(f"錯誤：視覺系統無法打開攝影機索引 {self.camera_index}。")
            return False
        write_log(f"視覺系統成功連接到攝影機索引 {self.camera_index}。")
        
        cv2.namedWindow('Vision System - Live Feed')
        cv2.setMouseCallback('Vision System - Live Feed', self._mouse_callback)
        return True

    def get_board_state(self):
        ret, frame = self.cap.read()
        if not ret:
            write_log("視覺系統：無法從攝影機讀取影像。")
            return None
        
        processed_display_frame = frame.copy() 
        board_state = {}

        if self.grid_map is not None:
            self._draw_grid_map(processed_display_frame)
            write_log("網格地圖已載入，正在進行棋子偵測...")
            board_state = self._detect_stones(frame)
            self._draw_stone_detections(processed_display_frame, board_state)
        elif len(self.manual_points) == self.BOARD_DIM * 2:
            write_log("所有校準點已點選。請按 '--- Save Grid Map ---' 按鈕保存網格地圖。")
            self._draw_manual_points(processed_display_frame)
        else:
            write_log(f"請依序點擊 {len(self.manual_points)}/{self.BOARD_DIM*2} 個網格點以進行校準。")
            self._draw_manual_points(processed_display_frame)

        cv2.imshow('Vision System - Live Feed', processed_display_frame)
        control_window_img = np.zeros((100, 500, 3), dtype=np.uint8)
        cv2.imshow(self.control_window_name, control_window_img)
        
        return board_state

    def _detect_stones(self, frame):
        """在已校準的網格上偵測黑子和白子。"""
        board_state = {}
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        
        for row in range(self.BOARD_DIM):
            for col in range(self.BOARD_DIM):
                x, y = tuple(self.grid_map[row, col])
                
                roi_x_min = max(0, x - self.stone_detection_roi_radius)
                roi_x_max = min(gray_frame.shape[1], x + self.stone_detection_roi_radius)
                roi_y_min = max(0, y - self.stone_detection_roi_radius)
                roi_y_max = min(gray_frame.shape[0], y + self.stone_detection_roi_radius)
                
                roi = gray_frame[roi_y_min:roi_y_max, roi_x_min:roi_x_max]
                if roi.size == 0:
                    continue

                average_brightness = np.mean(roi)
                if average_brightness < self.black_stone_thresh:
                    col_char = "ABCDEFGHJKLMNOPQRST"[col]
                    row_num = row + 1
                    board_state[f"{col_char}{row_num}"] = "B"
                elif average_brightness > self.white_stone_thresh:
                    col_char = "ABCDEFGHJKLMNOPQRST"[col]
                    row_num = row + 1
                    board_state[f"{col_char}{row_num}"] = "W"
        
        write_log(f"棋子偵測結果：偵測到 {len(board_state)} 個棋子。")
        return board_state

    def _draw_stone_detections(self, frame_to_draw, board_state):
        """在影像上繪製棋子偵測的結果，並用顏色標記"""
        for gtp_coord, stone_color in board_state.items():
            row = int(gtp_coord[1:]) - 1
            col = "ABCDEFGHJKLMNOPQRST".index(gtp_coord[0])
            p = tuple(self.grid_map[row, col])
            
            color_to_draw = (0, 0, 0) if stone_color == "B" else (255, 255, 255)
            cv2.circle(frame_to_draw, p, self.stone_detection_roi_radius, (0, 255, 255), 2)
            cv2.circle(frame_to_draw, p, self.stone_detection_roi_radius - 2, color_to_draw, -1)
            cv2.putText(frame_to_draw, stone_color, (p[0] - 5, p[1] + 5), 
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2, cv2.LINE_AA)

    def detect_human_move(self, prev_board_state, current_board_state):
        pass

    def stop_camera(self):
        if self.cap and self.cap.isOpened():
            self.cap.release()
        cv2.destroyAllWindows() 
        write_log("視覺系統攝影機已停止。")

    def _draw_manual_points(self, frame_to_draw):
        for i, p in enumerate(self.manual_points):
            color = self.manual_point_colors[i % 2]
            cv2.circle(frame_to_draw, p, 10, color, -1)
            if i < self.BOARD_DIM:
                text = f"X:{i+1}"
            else:
                text = f"Y:{i-self.BOARD_DIM+1}"
            cv2.putText(frame_to_draw, text, (p[0] + 15, p[1] + 15), 
                        cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2, cv2.LINE_AA)

    def _draw_grid_map(self, frame_to_draw):
        if self.grid_map is not None:
            for row in range(self.BOARD_DIM):
                for col in range(self.BOARD_DIM):
                    p = tuple(self.grid_map[row, col])
                    cv2.circle(frame_to_draw, p, 5, (0, 255, 0), -1) 
                    if row < self.BOARD_DIM - 1:
                        p2 = tuple(self.grid_map[row + 1, col])
                        cv2.line(frame_to_draw, p, p2, (0, 255, 0), 1)
                    if col < self.BOARD_DIM - 1:
                        p2 = tuple(self.grid_map[row, col + 1])
                        cv2.line(frame_to_draw, p, p2, (0, 255, 0), 1)

    def _sort_manual_corners(self, corners):
        corners = np.array(corners, dtype="float32")
        s = corners.sum(axis=1)
        top_left = corners[np.argmin(s)]
        bottom_right = corners[np.argmax(s)]
        diff = np.diff(corners, axis=1)
        top_right = corners[np.argmin(diff)] 
        bottom_left = corners[np.argmax(diff)] 
        return np.array([top_left, top_right, bottom_right, bottom_left], dtype="float32")

if __name__ == "__main__":
    vision_system = None
    try:
        vision_system = VisionSystem()
        if not vision_system.start_camera():
            write_log("視覺系統啟動失敗，無法進行單獨測試。")
            exit(1)
        write_log("\n✅ VisionSystem 單獨測試模式已啟動。")
        write_log("請將圍棋盤置於攝影機下方。按 'q' 鍵退出所有視窗。")

        while True:
            board_state = vision_system.get_board_state()
            write_log(f"當前黑子閾值: {vision_system.black_stone_thresh}, 白子閾值: {vision_system.white_stone_thresh}")
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                write_log("用戶手動退出 VisionSystem 單獨測試。")
                break
            
    except Exception as e:
        write_log(f"\n🚨 VisionSystem 單獨測試發生錯誤：{e}")
    finally:
        if vision_system:
            vision_system.stop_camera()
        write_log("VisionSystem 單獨測試程式結束。")